/**
 * Copyright Quadrivium LLC
 * All Rights Reserved
 * SPDX-License-Identifier: Apache-2.0
 */

#pragma once

#include <ec-cpp/ec-cpp.hpp>
#include <iostream>

#include "parachain/availability/erasure_coding_error.hpp"
#include "runtime/runtime_api/parachain_host_types.hpp"

#define _EC_CPP_TRY_VOID(tmp, expr)                                            \
  auto &&tmp = expr;                                                           \
  if (ec_cpp::resultHasError(tmp)) {                                           \
    return kagome::ErasureCodingError(                                         \
        kagome::toErasureCodingError(ec_cpp::resultGetError(std::move(tmp)))); \
  }
#define _EC_CPP_TRY_OUT(tmp, out, expr) \
  _EC_CPP_TRY_VOID(tmp, expr);          \
  auto out = ec_cpp::resultGetValue(std::move(tmp));
#define EC_CPP_TRY(out, expr) _EC_CPP_TRY_OUT(OUTCOME_UNIQUE, out, expr)

namespace kagome::parachain {
  inline outcome::result<size_t> minChunks(size_t validators) {
    EC_CPP_TRY(min, ec_cpp::getRecoveryThreshold(validators));
    return min;
  }

  inline outcome::result<std::vector<network::ErasureChunk>> toChunks(
      size_t validators, const runtime::AvailableData &data) {
    OUTCOME_TRY(message, scale::encode(data));

    /*
    validators: 4
    input: 0x84, 0x52, 0xbc, 0x53, 0x76, 0x46, 0xdb, 0x8e, 0x5, 0x28, 0xb5,
    0x2f, 0xfd, 0x0, 0x58, 0x81, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x21, 0x1, 0x7, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x64, 0x2d, 0xf8, 0xc8, 0x8b, 0x9f, 0x15, 0x1a, 0x0,
    0xc9, 0xba, 0x5c, 0x5c, 0x74, 0x70, 0xc0, 0xd6, 0x49, 0xe9, 0x4d, 0xf1,
    0x39, 0xe5, 0xa3, 0xaa, 0x84, 0x56, 0x92, 0x50, 0x78, 0x63, 0xb1, 0x76,
    0x7d, 0x5e, 0xa0, 0x9e, 0xc4, 0x92, 0x73, 0x15, 0x34, 0x43, 0xb6, 0xda, 0x3,
    0x61, 0x86, 0x44, 0x54, 0xcc, 0x41, 0x8, 0x30, 0x8f, 0x37, 0x29, 0xc4, 0x5c,
    0x45, 0x8, 0x4f, 0x26, 0xe1, 0x12, 0x0, 0x0, 0x0, 0xfc, 0xce, 0x65, 0x36,
    0xc9, 0xfb, 0x2b, 0x7c, 0x97, 0xbb, 0x8, 0x15, 0xf3, 0x37, 0x70, 0x14, 0xe1,
    0x2a, 0x43, 0x6f, 0x24, 0x79, 0x8c, 0x9, 0xe5, 0x68, 0x4f, 0x83, 0x53, 0x87,
    0xc1, 0x7a, 0x0, 0x0, 0x50, 0x0, output: shard: 0x84, 0x52, 0x76, 0x46, 0x5,
    0x28, 0xfd, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x0,
    0x0, 0x0, 0x64, 0x2d, 0x8b, 0x9f, 0x0, 0xc9, 0x5c, 0x74, 0xd6, 0x49, 0xf1,
    0x39, 0xaa, 0x84, 0x50, 0x78, 0x76, 0x7d, 0x9e, 0xc4, 0x15, 0x34, 0xda, 0x3,
    0x44, 0x54, 0x8, 0x30, 0x29, 0xc4, 0x8, 0x4f, 0x12, 0x0, 0xfc, 0xce, 0xc9,
    0xfb, 0x97, 0xbb, 0xf3, 0x37, 0xe1, 0x2a, 0x24, 0x79, 0xe5, 0x68, 0x53,
    0x87, 0x0, 0x0, shard: 0xbc, 0x53, 0xdb, 0x8e, 0xb5, 0x2f, 0x58, 0x81, 0xe,
    0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x21, 0x1, 0x0, 0x0, 0x0, 0x0, 0xf8,
    0xc8, 0x15, 0x1a, 0xba, 0x5c, 0x70, 0xc0, 0xe9, 0x4d, 0xe5, 0xa3, 0x56,
    0x92, 0x63, 0xb1, 0x5e, 0xa0, 0x92, 0x73, 0x43, 0xb6, 0x61, 0x86, 0xcc,
    0x41, 0x8f, 0x37, 0x5c, 0x45, 0x26, 0xe1, 0x0, 0x0, 0x65, 0x36, 0x2b, 0x7c,
    0x8, 0x15, 0x70, 0x14, 0x43, 0x6f, 0x8c, 0x9, 0x4f, 0x83, 0xc1, 0x7a, 0x50,
    0x0, shard: 0x9f, 0x29, 0xaf, 0x81, 0xf7, 0xcc, 0x2a, 0x6, 0x6, 0xde, 0x0,
    0x0, 0x3, 0x9f, 0x0, 0x0, 0x3b, 0x37, 0xd, 0x6f, 0x0, 0x0, 0xaa, 0x1c, 0x46,
    0xbb, 0xff, 0x4, 0x60, 0x36, 0xc7, 0x54, 0xd6, 0x3d, 0xee, 0xfb, 0x44, 0x77,
    0x41, 0x86, 0x9b, 0x7d, 0x82, 0x79, 0x27, 0x2d, 0xad, 0xe6, 0xe5, 0xbc,
    0x86, 0x22, 0x37, 0xb3, 0x3d, 0x62, 0x3b, 0x24, 0xa7, 0x6e, 0x58, 0x66,
    0x15, 0xb6, 0x3c, 0x1c, 0xf4, 0xb2, 0x36, 0xf8, 0x9b, 0x4a, 0x9f, 0x9,
    shard: 0xa7, 0x28, 0x2, 0x49, 0x47, 0xcb, 0x8f, 0x87, 0x8, 0xde, 0x0, 0x0,
    0x1, 0x9f, 0x0, 0x0, 0x1a, 0x36, 0xa, 0x6f, 0x0, 0x0, 0x36, 0xf9, 0xd8,
    0x3e, 0x45, 0x91, 0x4c, 0x82, 0xf8, 0x50, 0xc2, 0xa7, 0x12, 0xed, 0x77,
    0xbe, 0x69, 0x5b, 0x97, 0xca, 0xd4, 0xfb, 0x9c, 0xa8, 0x25, 0xf3, 0x62,
    0xbb, 0xf3, 0xa3, 0x19, 0x1d, 0x2f, 0x62, 0xa2, 0xdc, 0x45, 0xe9, 0xc7,
    0xc8, 0x96, 0x95, 0x9e, 0x59, 0x5c, 0xc2, 0x9c, 0x13, 0x9, 0xb7, 0xcf, 0x9,
    */

    std::string s = fmt::format("validators: {}\ninput: ", validators);
    for (const auto m : message) {
      s += fmt::format("{:x}, ", m);
    }

    EC_CPP_TRY(encoder, ec_cpp::create(validators));
    EC_CPP_TRY(
        shards,
        encoder.encode(ec_cpp::Slice<uint8_t>(message.data(), message.size())));
    BOOST_ASSERT(shards.size() == validators);

    s += "\noutput:";
    for (const auto &shard : shards) {
      s += "\nshard: ";
      for (const auto m : shard) {
        s += fmt::format("{:x}, ", m);
      }
    }
    std::cout << s << std::endl;

    std::vector<network::ErasureChunk> chunks;
    chunks.resize(validators);
    for (size_t i = 0; i < validators; ++i) {
      auto &chunk = chunks[i];
      chunk.index = i;
      chunk.chunk = std::move(shards[i]);
    }
    return chunks;
  }

  inline outcome::result<runtime::AvailableData> fromChunks(
      size_t validators, const std::vector<network::ErasureChunk> &chunks) {
    EC_CPP_TRY(encoder, ec_cpp::create(validators));
    std::vector<decltype(encoder)::Shard> _chunks;
    _chunks.resize(validators);
    for (size_t i = 0; i < chunks.size(); ++i) {
      const auto &chunk = chunks[i];
      if (chunk.index < validators) {
        _chunks[chunk.index] = chunk.chunk;
      }
    }

    EC_CPP_TRY(data, encoder.reconstruct(_chunks));
    return scale::decode<runtime::AvailableData>(data);
  }
}  // namespace kagome::parachain

#undef ERASURE_CODING_ERROR
